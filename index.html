<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#1a1a2e">
<link rel="manifest" href="manifest.json">
<link rel="apple-touch-icon" href="icons/icon-192.png">
<title>Picasso Catch Game</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #000; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
(() => {
  // ‚îÄ‚îÄ‚îÄ Game Version ‚îÄ‚îÄ‚îÄ
  const GAME_VERSION = 'v3.0'; // Increment this with each major update
  
  // ‚îÄ‚îÄ‚îÄ Canvas Setup ‚îÄ‚îÄ‚îÄ
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resize);
  resize();

  // ‚îÄ‚îÄ‚îÄ Sound Effects (Web Audio API) ‚îÄ‚îÄ‚îÄ
  let soundEnabled = true;

  function playSound(type) {
    if (!soundEnabled) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);

    const now = audioCtx.currentTime;
    
    switch(type) {
      case 'catch1': // 1 point item
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.exponentialRampToValueAtTime(660, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
        break;
      case 'catch2': // 2 point item
        osc.frequency.setValueAtTime(660, now);
        osc.frequency.exponentialRampToValueAtTime(880, now + 0.15);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
      case 'combo':
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.exponentialRampToValueAtTime(1320, now + 0.2);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        break;
      case 'powerup':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(880, now + 0.3);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
        break;
      case 'miss':
        osc.frequency.setValueAtTime(220, now);
        osc.frequency.exponentialRampToValueAtTime(110, now + 0.3);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
        break;
      case 'pizza':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.exponentialRampToValueAtTime(55, now + 0.5);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc.start(now);
        osc.stop(now + 0.5);
        break;
      case 'achievement':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(523, now);
        osc.frequency.setValueAtTime(659, now + 0.1);
        osc.frequency.setValueAtTime(784, now + 0.2);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(now);
        osc.stop(now + 0.4);
        break;
    }
  }

  // ‚îÄ‚îÄ‚îÄ Particle System ‚îÄ‚îÄ‚îÄ
  let particles = [];
  let screenShake = 0;

  function createParticles(x, y, count, color, size = 3) {
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
      const speed = 2 + Math.random() * 4;
      particles.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed - 2,
        life: 1,
        decay: 0.015 + Math.random() * 0.01,
        color,
        size
      });
    }
  }

  function updateParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2; // gravity
      p.life -= p.decay;
      if (p.life <= 0) particles.splice(i, 1);
    }
    if (screenShake > 0) screenShake *= 0.9;
    if (screenShake < 0.1) screenShake = 0;
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    });
    ctx.globalAlpha = 1;
  }

  // ‚îÄ‚îÄ‚îÄ Asset Loading ‚îÄ‚îÄ‚îÄ
  const SPRITE_NAMES = ['picasso', 'hrs', 'sus', 'muckalica', 'pizza'];
  const sprites = {};
  const alphaMasks = {};  // pre-computed alpha masks for pixel-perfect collision
  let assetsLoaded = 0;

  // Build a boolean alpha mask at a given render size
  function buildAlphaMask(img, w, h) {
    const offscreen = document.createElement('canvas');
    offscreen.width = w;
    offscreen.height = h;
    const offCtx = offscreen.getContext('2d');
    offCtx.drawImage(img, 0, 0, w, h);
    const data = offCtx.getImageData(0, 0, w, h).data;
    const mask = new Uint8Array(w * h);
    for (let i = 0; i < w * h; i++) {
      mask[i] = data[i * 4 + 3] > 20 ? 1 : 0;  // alpha threshold of 20
    }
    return { mask, w, h };
  }

  function loadAssets(callback) {
    SPRITE_NAMES.forEach(name => {
      const img = new Image();
      img.src = 'sprites/' + name + '.png';
      img.onload = () => {
        // Build masks at the sizes used in-game
        const mw = (name === 'picasso') ? PLAYER_WIDTH : ITEM_SIZE;
        const mh = (name === 'picasso') ? PLAYER_HEIGHT : ITEM_SIZE;
        alphaMasks[name] = buildAlphaMask(img, mw, mh);
        assetsLoaded++;
        if (assetsLoaded === SPRITE_NAMES.length) callback();
      };
      img.onerror = () => {
        console.error('Failed to load: ' + name + '.png');
        assetsLoaded++;
        if (assetsLoaded === SPRITE_NAMES.length) callback();
      };
      sprites[name] = img;
    });
  }

  // ‚îÄ‚îÄ‚îÄ Game Constants ‚îÄ‚îÄ‚îÄ
  const PLAYER_WIDTH = 100;
  const PLAYER_HEIGHT = 100;
  const ITEM_SIZE = 65;
  const PLAYER_SPEED = 7;
  const INITIAL_FALL_SPEED = 2.5;
  const INITIAL_SPAWN_INTERVAL = 1200; // ms
  const DIFFICULTY_INTERVAL = 15000;   // ramp every 15s
  const SPEED_INCREMENT = 0.4;
  const SPAWN_DECREMENT = 80;          // ms faster spawn
  const MIN_SPAWN_INTERVAL = 400;
  const MAX_LIVES = 3;

  const FOOD_TYPES = [
    { name: 'hrs',       points: 2, deadly: false },
    { name: 'sus',       points: 2, deadly: false },
    { name: 'muckalica', points: 1, deadly: false },
    { name: 'pizza',     points: 0, deadly: true  },
  ];

  const POWER_UP_TYPES = [
    { type: 'shield', color: '#4ECDC4', duration: 0, icon: 'üõ°Ô∏è' },
    { type: 'slowmo', color: '#95E1D3', duration: 5000, icon: '‚è±Ô∏è' },
    { type: 'magnet', color: '#F38181', duration: 7000, icon: 'üß≤' },
    { type: 'double', color: '#FFD93D', duration: 10000, icon: '2√ó' },
  ];

  const ACHIEVEMENTS = [
    { id: 'first_catch', name: 'First Catch', desc: 'Catch your first item', check: s => s.totalCatches >= 1 },
    { id: 'combo_5', name: 'Combo Starter', desc: 'Get a 5√ó combo', check: s => s.maxCombo >= 5 },
    { id: 'combo_10', name: 'Combo Master', desc: 'Get a 10√ó combo', check: s => s.maxCombo >= 10 },
    { id: 'score_50', name: 'Half Century', desc: 'Score 50 points', check: s => s.maxScore >= 50 },
    { id: 'score_100', name: 'Centurion', desc: 'Score 100 points', check: s => s.maxScore >= 100 },
    { id: 'survive_60', name: 'One Minute', desc: 'Survive 60 seconds', check: s => s.maxSurvivalTime >= 60 },
    { id: 'pizza_dodge', name: 'Pizza Dodger', desc: 'Let 5 pizzas fall', check: s => s.pizzasDodged >= 5 },
    { id: 'no_miss_10', name: 'Perfect 10', desc: 'Catch 10 in a row without missing', check: s => s.maxCombo >= 10 },
  ];

  // ‚îÄ‚îÄ‚îÄ Game Modes ‚îÄ‚îÄ‚îÄ
  const GAME_MODES = {
    NORMAL: {
      id: 'normal',
      name: 'Normal',
      desc: 'Classic gameplay with lives and power-ups',
      icon: 'üéÆ',
      lives: 3,
      powerUps: true,
      timeLimit: null,
      speedMultiplier: 1
    },
    ZEN: {
      id: 'zen',
      name: 'Zen Mode',
      desc: 'Relaxing endless mode - no lives, no pressure',
      icon: 'üßò',
      lives: Infinity,
      powerUps: true,
      timeLimit: null,
      speedMultiplier: 0.7
    },
    TIME_ATTACK: {
      id: 'time',
      name: 'Time Attack',
      desc: '60 seconds - get the highest score possible!',
      icon: '‚è±Ô∏è',
      lives: Infinity,
      powerUps: true,
      timeLimit: 60000,
      speedMultiplier: 1.2
    },
    HARDCORE: {
      id: 'hardcore',
      name: 'Hardcore',
      desc: 'Fast from the start, no power-ups, 2 lives',
      icon: 'üíÄ',
      lives: 2,
      powerUps: false,
      timeLimit: null,
      speedMultiplier: 1.5
    }
  };

  // ‚îÄ‚îÄ‚îÄ Game State ‚îÄ‚îÄ‚îÄ
  let player, items = [], score, lives, gameOver = false, fallSpeed, spawnInterval;
  let lastSpawn, lastDifficulty, gameStartTime, keys = {}, animFrameId;
  let combo, comboTimer, maxCombo, activePowerUps = [], lastPowerUpSpawn;
  let stats, unlockedAchievements, newAchievements = [];
  let paused = false, showPauseMenu = false, tiltEnabled, pauseStartTime;
  let currentMode = GAME_MODES.NORMAL;
  let showModeSelect = false;
  let showTutorial = false;
  let tutorialStep = 0;
  let playerName = '';
  let highScores;
  
  // Mobile detection
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Haptic feedback support
  function vibrate(duration = 10) {
    if (navigator.vibrate && isMobile) {
      navigator.vibrate(duration);
    }
  }

  // Load persistent stats from localStorage
  function loadStats() {
    const saved = localStorage.getItem('picassoStats');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch(e) {}
    }
    return {
      totalCatches: 0,
      maxScore: 0,
      maxCombo: 0,
      maxSurvivalTime: 0,
      pizzasDodged: 0,
      gamesPlayed: 0
    };
  }

  function saveStats() {
    localStorage.setItem('picassoStats', JSON.stringify(stats));
  }

  function loadSettings() {
    const saved = localStorage.getItem('picassoSettings');
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch(e) {}
    }
    return {
      soundEnabled: true,
      tiltEnabled: false
    };
  }

  function saveSettings() {
    localStorage.setItem('picassoSettings', JSON.stringify({
      soundEnabled,
      tiltEnabled
    }));
  }

  // Leaderboard system
  function loadLeaderboard(mode) {
    const saved = localStorage.getItem(`picassoLeaderboard_${mode}`);
    if (saved) {
      try {
        return JSON.parse(saved);
      } catch(e) {}
    }
    return [];
  }

  function saveLeaderboard(mode, scores) {
    localStorage.setItem(`picassoLeaderboard_${mode}`, JSON.stringify(scores));
  }

  function addHighScore(mode, playerScore, playerNameInput) {
    const scores = loadLeaderboard(mode);
    scores.push({
      name: playerNameInput || 'Anonymous',
      score: playerScore,
      combo: maxCombo,
      date: new Date().toISOString()
    });
    scores.sort((a, b) => b.score - a.score);
    const trimmed = scores.slice(0, 10); // Keep top 10
    saveLeaderboard(mode, trimmed);
    return trimmed;
  }

  function isHighScore(mode, playerScore) {
    const scores = loadLeaderboard(mode);
    return scores.length < 10 || playerScore > scores[scores.length - 1].score;
  }

  // Tutorial system
  function hasSeenTutorial() {
    return localStorage.getItem('picassoTutorialSeen') === 'true';
  }

  function markTutorialSeen() {
    localStorage.setItem('picassoTutorialSeen', 'true');
  }

  function loadAchievements() {
    const saved = localStorage.getItem('picassoAchievements');
    return saved ? JSON.parse(saved) : [];
  }

  function saveAchievements() {
    localStorage.setItem('picassoAchievements', JSON.stringify(unlockedAchievements));
  }

  function checkAchievements() {
    ACHIEVEMENTS.forEach(ach => {
      if (!unlockedAchievements.includes(ach.id) && ach.check(stats)) {
        unlockedAchievements.push(ach.id);
        newAchievements.push(ach);
        playSound('achievement');
        saveAchievements();
      }
    });
  }

  function resetState() {
    const mode = currentMode || GAME_MODES.NORMAL;
    
    player = {
      x: canvas.width / 2 - PLAYER_WIDTH / 2,
      y: canvas.height - PLAYER_HEIGHT - 10,
      w: PLAYER_WIDTH,
      h: PLAYER_HEIGHT,
    };
    items = [];
    score = 0;
    lives = mode.lives === Infinity ? Infinity : mode.lives;
    gameOver = false;
    paused = false;
    showPauseMenu = false;
    pauseStartTime = 0;
    fallSpeed = INITIAL_FALL_SPEED * mode.speedMultiplier;
    spawnInterval = INITIAL_SPAWN_INTERVAL;
    lastSpawn = 0;
    lastDifficulty = 0;
    lastPowerUpSpawn = 0;
    gameStartTime = performance.now();
    combo = 0;
    comboTimer = 0;
    maxCombo = 0;
    activePowerUps = [];
    particles = [];
    screenShake = 0;
    newAchievements = [];
    keys = {};
    stats.gamesPlayed++;
  }

  stats = loadStats();
  unlockedAchievements = loadAchievements();
  const settings = loadSettings();
  soundEnabled = settings.soundEnabled;
  tiltEnabled = settings.tiltEnabled;
  currentMode = GAME_MODES.NORMAL;
  showModeSelect = true;
  showTutorial = !hasSeenTutorial();
  tutorialStep = 0;
  playerName = localStorage.getItem('picassoPlayerName') || '';
  highScores = {};

  // ‚îÄ‚îÄ‚îÄ Input Handling ‚îÄ‚îÄ‚îÄ
  window.addEventListener('keydown', e => {
    keys[e.key] = true;

    // Name entry for high score
    if (gameOver && isHighScore(currentMode.id, score) && !playerName) {
      if (e.key === 'Enter' && playerName && playerName.trim().length > 0) {
        // Save high score with name
        addHighScore(currentMode.id, score, playerName.trim());
        return;
      }
      if (e.key === 'Backspace') {
        playerName = playerName.slice(0, -1);
        return;
      }
      if (e.key.length === 1 && playerName.length < 15) {
        playerName += e.key;
        return;
      }
      return; // Block other keys during name entry
    }

    // Tutorial navigation
    if (showTutorial) {
      if (e.key === 'Enter' || e.key === ' ') {
        tutorialStep++;
        if (tutorialStep >= 4) {
          showTutorial = false;
          markTutorialSeen();
          showModeSelect = true;
        }
        return;
      }
      if (e.key === 'Escape') {
        showTutorial = false;
        markTutorialSeen();
        tutorialStep = 0;
        showModeSelect = true;
        return;
      }
      return; // Block other keys during tutorial
    }

    // Mode selection with number keys
    if (showModeSelect) {
      const modes = ['NORMAL', 'ZEN', 'TIME_ATTACK', 'HARDCORE'];
      if (e.key >= '1' && e.key <= '4') {
        currentMode = GAME_MODES[modes[e.key - 1]];
        showModeSelect = false;
        startGame();
        return;
      }
      return; // Block other keys during mode select
    }

    // Restart on Enter when game is over
    if (gameOver && e.key === 'Enter') {
      startGame();
      return;
    }

    // Return to mode select from game over
    if (gameOver && (e.key === 'm' || e.key === 'M')) {
      showModeSelect = true;
      playerName = '';
      return;
    }

    // Pause toggle (Escape or P)
    if ((e.key === 'Escape' || e.key === 'p' || e.key === 'P') && !gameOver) {
      togglePause();
      return;
    }
    // Mute toggle
    if (e.key === 'm' || e.key === 'M') {
      soundEnabled = !soundEnabled;
      saveSettings();
    }
  });
  window.addEventListener('keyup', e => { keys[e.key] = false; });

  // Tilt controls (device orientation)
  let tiltX = 0;
  if (isMobile && window.DeviceOrientationEvent) {
    window.addEventListener('deviceorientation', e => {
      if (!tiltEnabled || !e.gamma) return;
      // gamma is tilt left/right: -90 to 90
      tiltX = Math.max(-30, Math.min(30, e.gamma)) / 30; // normalize to -1 to 1
    });
  }

  function togglePause() {
    if (paused) {
      // Resume
      const pauseDuration = performance.now() - pauseStartTime;
      gameStartTime += pauseDuration;
      lastSpawn += pauseDuration;
      lastDifficulty += pauseDuration;
      lastPowerUpSpawn += pauseDuration;
      paused = false;
      showPauseMenu = false;
    } else {
      // Pause
      paused = true;
      showPauseMenu = !isMobile; // Auto-show menu on desktop
      pauseStartTime = performance.now();
    }
  }

  // Mouse / touch control
  let pointerX = null;
  let touchStartX = null;
  
  canvas.addEventListener('mousemove', e => { 
    if (!isMobile) pointerX = e.clientX; 
  });
  
  canvas.addEventListener('touchstart', e => {
    touchStartX = e.touches[0].clientX;
  }, { passive: true });
  
  canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const touch = e.touches[0];
    pointerX = touch.clientX;
  }, { passive: false });
  
  canvas.addEventListener('touchend', e => { 
    const touch = e.changedTouches[0];
    
    // Check if tapped pause button (top-left corner on mobile)
    if (!gameOver && isMobile) {
      const pauseButtonSize = 55;
      if (touch.clientX < pauseButtonSize && touch.clientY < pauseButtonSize) {
        if (paused) {
          showPauseMenu = !showPauseMenu;
        } else {
          paused = true;
          showPauseMenu = true;
          pauseStartTime = performance.now();
        }
        vibrate(10);
        e.preventDefault();
        pointerX = null;
        touchStartX = null;
        return;
      }
    }
    
    pointerX = null;
    touchStartX = null;
  });
  
  canvas.addEventListener('click', e => {
    const x = e.clientX;
    const y = e.clientY;

    // Mode Selection
    if (showModeSelect) {
      const centerX = canvas.width / 2;
      const buttonWidth = 300;
      const buttonHeight = 80;
      const startY = 220;
      const spacing = 100;
      const modes = ['NORMAL', 'ZEN', 'TIME_ATTACK', 'HARDCORE'];

      for (let i = 0; i < modes.length; i++) {
        const btnY = startY + i * spacing;
        if (x >= centerX - buttonWidth / 2 && x <= centerX + buttonWidth / 2 &&
            y >= btnY && y <= btnY + buttonHeight) {
          currentMode = GAME_MODES[modes[i]];
          showModeSelect = false;
          vibrate(10);
          startGame();
          return;
        }
      }
      return;
    }

    // Tutorial
    if (showTutorial) {
      const btnY = canvas.height - 80;
      
      // Next/Start button
      if (x >= canvas.width / 2 - 100 && x <= canvas.width / 2 + 100 &&
          y >= btnY && y <= btnY + 50) {
        tutorialStep++;
        if (tutorialStep >= 4) {
          showTutorial = false;
          markTutorialSeen();
          showModeSelect = true;
        }
        vibrate(8);
        return;
      }

      // Skip button
      if (tutorialStep < 3 && y >= canvas.height - 35 && y <= canvas.height - 5) {
        showTutorial = false;
        markTutorialSeen();
        tutorialStep = 0;
        showModeSelect = true;
        vibrate(8);
        return;
      }
      return;
    }

    // Name entry for high score (mobile)
    if (gameOver && isHighScore(currentMode.id, score) && !playerName && isMobile) {
      const namePrompt = prompt('üèÜ New High Score!\n\nEnter your name:');
      if (namePrompt && namePrompt.trim().length > 0) {
        playerName = namePrompt.trim().substring(0, 15);
        addHighScore(currentMode.id, score, playerName);
      }
      return;
    }

    // Game over - restart or mode select
    if (gameOver) {
      // Check if clicking on mode select hint area
      const leaderboard = loadLeaderboard(currentMode.id);
      const promptY = leaderboard.length > 0 ? 460 : 260;
      if (y >= promptY + 10 && y <= promptY + 40) {
        // Clicking on "Press M to change mode" area
        showModeSelect = true;
        playerName = '';
        vibrate(10);
      } else {
        // Regular restart
        startGame();
      }
      return;
    }
    
    // Handle pause menu clicks
    if (paused && showPauseMenu) {
      handlePauseMenuClick(e.clientX, e.clientY);
    }
  });

  function handlePauseMenuClick(x, y) {
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const buttonWidth = 200;
    const buttonHeight = 50;
    const spacing = 15;

    // Resume button
    if (x >= centerX - buttonWidth / 2 && x <= centerX + buttonWidth / 2 &&
        y >= centerY - 60 && y <= centerY - 10) {
      togglePause();
      vibrate(10);
      return;
    }

    // Sound toggle button
    if (x >= centerX - buttonWidth / 2 && x <= centerX + buttonWidth / 2 &&
        y >= centerY + 10 && y <= centerY + 60) {
      soundEnabled = !soundEnabled;
      saveSettings();
      vibrate(10);
      return;
    }

    // Tilt controls toggle (mobile only)
    if (isMobile && x >= centerX - buttonWidth / 2 && x <= centerX + buttonWidth / 2 &&
        y >= centerY + 75 && y <= centerY + 125) {
      tiltEnabled = !tiltEnabled;
      saveSettings();
      vibrate(10);
      return;
    }

    // Reset stats button
    const resetY = isMobile ? centerY + 140 : centerY + 75;
    if (x >= centerX - buttonWidth / 2 && x <= centerX + buttonWidth / 2 &&
        y >= resetY && y <= resetY + 50) {
      if (confirm('Reset all stats and achievements?')) {
        localStorage.removeItem('picassoStats');
        localStorage.removeItem('picassoAchievements');
        stats = loadStats();
        unlockedAchievements = loadAchievements();
        vibrate(20);
      }
      return;
    }
  }

  // ‚îÄ‚îÄ‚îÄ Spawning ‚îÄ‚îÄ‚îÄ
  function spawnItem() {
    const type = FOOD_TYPES[Math.floor(Math.random() * FOOD_TYPES.length)];
    const x = Math.random() * (canvas.width - ITEM_SIZE);
    items.push({ x, y: -ITEM_SIZE, w: ITEM_SIZE, h: ITEM_SIZE, type, isPowerUp: false });
  }

  function spawnPowerUp() {
    const powerUp = POWER_UP_TYPES[Math.floor(Math.random() * POWER_UP_TYPES.length)];
    const x = Math.random() * (canvas.width - ITEM_SIZE);
    items.push({ 
      x, y: -ITEM_SIZE, w: ITEM_SIZE, h: ITEM_SIZE, 
      powerUp, 
      isPowerUp: true,
      type: { name: 'powerup', points: 0, deadly: false }
    });
  }

  function activatePowerUp(powerUp) {
    playSound('powerup');
    if (powerUp.type === 'shield') {
      // Shield gives 1 extra life
      if (lives < MAX_LIVES) lives++;
    } else {
      // Timed power-ups
      const existing = activePowerUps.find(p => p.type === powerUp.type);
      if (existing) {
        existing.endTime = performance.now() + powerUp.duration;
      } else {
        activePowerUps.push({
          type: powerUp.type,
          endTime: performance.now() + powerUp.duration,
          ...powerUp
        });
      }
    }
  }

  function updatePowerUps(now) {
    activePowerUps = activePowerUps.filter(p => now < p.endTime);
  }

  function hasPowerUp(type) {
    return activePowerUps.some(p => p.type === type);
  }

  // ‚îÄ‚îÄ‚îÄ Collision (pixel-perfect) ‚îÄ‚îÄ‚îÄ
  function aabbOverlaps(a, b) {
    return a.x < b.x + b.w &&
           a.x + a.w > b.x &&
           a.y < b.y + b.h &&
           a.y + a.h > b.y;
  }

  function pixelOverlaps(a, aMaskName, b, bMaskName) {
    // Fast AABB rejection first
    if (!aabbOverlaps(a, b)) return false;

    const maskA = alphaMasks[aMaskName];
    const maskB = alphaMasks[bMaskName];
    if (!maskA || !maskB) return true; // fallback if mask missing

    // Compute overlapping rectangle in world coordinates
    const left   = Math.max(a.x, b.x);
    const right  = Math.min(a.x + a.w, b.x + b.w);
    const top    = Math.max(a.y, b.y);
    const bottom = Math.min(a.y + a.h, b.y + b.h);

    // Sample every 2 pixels for performance
    const step = 2;
    for (let wy = top; wy < bottom; wy += step) {
      for (let wx = left; wx < right; wx += step) {
        const ax = Math.floor(wx - a.x);
        const ay = Math.floor(wy - a.y);
        const bx = Math.floor(wx - b.x);
        const by = Math.floor(wy - b.y);

        if (ax >= 0 && ax < maskA.w && ay >= 0 && ay < maskA.h &&
            bx >= 0 && bx < maskB.w && by >= 0 && by < maskB.h) {
          if (maskA.mask[ay * maskA.w + ax] && maskB.mask[by * maskB.w + bx]) {
            return true;
          }
        }
      }
    }
    return false;
  }

  // ‚îÄ‚îÄ‚îÄ Update ‚îÄ‚îÄ‚îÄ
  function update(now) {
    if (gameOver || paused) return;

    updateParticles();
    updatePowerUps(now);

    // Time Attack mode - check time limit
    if (currentMode.timeLimit) {
      const elapsed = now - gameStartTime;
      if (elapsed >= currentMode.timeLimit) {
        gameOver = true;
        
        // Update stats
        stats.maxScore = Math.max(stats.maxScore, score);
        stats.maxCombo = Math.max(stats.maxCombo, maxCombo);
        saveStats();
        checkAchievements();
        return;
      }
    }

    // Combo timer decay
    if (comboTimer > 0) {
      comboTimer -= 16.67; // ~60fps
      if (comboTimer <= 0) {
        combo = 0;
      }
    }

    // Player movement ‚Äî keyboard
    if (keys['ArrowLeft'] || keys['a']) player.x -= PLAYER_SPEED;
    if (keys['ArrowRight'] || keys['d']) player.x += PLAYER_SPEED;

    // Player movement ‚Äî tilt (mobile)
    if (tiltEnabled && tiltX !== 0) {
      player.x += tiltX * PLAYER_SPEED;
    }

    // Player movement ‚Äî mouse/touch
    if (pointerX !== null && !tiltEnabled) {
      const target = pointerX - player.w / 2;
      const dx = target - player.x;
      player.x += dx * 0.2; // slightly faster for mobile
    }

    // Clamp to screen
    player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
    // Keep player at bottom on resize
    player.y = canvas.height - PLAYER_HEIGHT - 10;

    // Difficulty ramp
    const elapsed = now - gameStartTime;
    if (elapsed - lastDifficulty >= DIFFICULTY_INTERVAL) {
      lastDifficulty = elapsed;
      fallSpeed += SPEED_INCREMENT;
      spawnInterval = Math.max(MIN_SPAWN_INTERVAL, spawnInterval - SPAWN_DECREMENT);
    }

    // Spawn items
    if (now - lastSpawn >= spawnInterval) {
      spawnItem();
      lastSpawn = now;
    }

    // Spawn power-ups (every 20-30 seconds) - disabled in hardcore mode
    if (currentMode.powerUps && now - lastPowerUpSpawn >= 20000 + Math.random() * 10000) {
      spawnPowerUp();
      lastPowerUpSpawn = now;
    }

    // Current fall speed (affected by slowmo)
    const currentFallSpeed = hasPowerUp('slowmo') ? fallSpeed * 0.5 : fallSpeed;

    // Magnet effect
    const magnetRange = hasPowerUp('magnet') ? 80 : 0;

    // Move items & check collisions
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      item.y += currentFallSpeed;

      // Magnet attraction
      if (magnetRange > 0 && !item.isPowerUp && !item.type.deadly) {
        const dx = (player.x + player.w / 2) - (item.x + item.w / 2);
        const dy = (player.y + player.h / 2) - (item.y + item.h / 2);
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < magnetRange && dist > 0) {
          item.x += (dx / dist) * 3;
          item.y += (dy / dist) * 3;
        }
      }

      // Caught by player (pixel-perfect)
      const collides = item.isPowerUp 
        ? aabbOverlaps(player, item)  // Simple AABB for power-ups
        : pixelOverlaps(player, 'picasso', item, item.type.name);

      if (collides) {
        if (item.isPowerUp) {
          activatePowerUp(item.powerUp);
          createParticles(item.x + item.w / 2, item.y + item.h / 2, 15, item.powerUp.color, 4);
          vibrate(15);
          items.splice(i, 1);
          continue;
        }

        if (item.type.deadly) {
          playSound('pizza');
          screenShake = 15;
          createParticles(item.x + item.w / 2, item.y + item.h / 2, 20, '#ff6b6b', 5);
          vibrate(50);
          gameOver = true;
          
          // Update stats
          const survivalTime = Math.floor((now - gameStartTime) / 1000);
          stats.maxScore = Math.max(stats.maxScore, score);
          stats.maxCombo = Math.max(stats.maxCombo, maxCombo);
          stats.maxSurvivalTime = Math.max(stats.maxSurvivalTime, survivalTime);
          saveStats();
          checkAchievements();
          return;
        }

        // Successful catch
        const pointsEarned = item.type.points * (hasPowerUp('double') ? 2 : 1);
        score += pointsEarned;
        combo++;
        comboTimer = 2000; // 2 seconds to maintain combo
        maxCombo = Math.max(maxCombo, combo);
        stats.totalCatches++;
        
        // Haptic feedback - stronger for high combos
        vibrate(combo >= 5 ? 15 : 8);
        
        // Sound and particles
        if (combo >= 5) {
          playSound('combo');
        } else {
          playSound(item.type.points === 2 ? 'catch2' : 'catch1');
        }

        const particleColor = item.type.points === 2 ? '#FFD700' : '#4ECDC4';
        createParticles(item.x + item.w / 2, item.y + item.h / 2, 12, particleColor);
        
        items.splice(i, 1);
        continue;
      }

      // Fell off bottom
      if (item.y > canvas.height) {
        if (item.isPowerUp) {
          items.splice(i, 1);
          continue;
        }

        if (item.type.deadly) {
          // Pizza dodged successfully
          stats.pizzasDodged++;
          items.splice(i, 1);
          continue;
        }

        // Missed a food item
        playSound('miss');
        vibrate(20);
        combo = 0; // Break combo
        comboTimer = 0;
        lives--;
        screenShake = 8;
        createParticles(item.x + item.w / 2, canvas.height - 20, 8, '#ff6b6b');

        if (lives <= 0) {
          gameOver = true;
          
          // Update stats
          const survivalTime = Math.floor((now - gameStartTime) / 1000);
          stats.maxScore = Math.max(stats.maxScore, score);
          stats.maxCombo = Math.max(stats.maxCombo, maxCombo);
          stats.maxSurvivalTime = Math.max(stats.maxSurvivalTime, survivalTime);
          saveStats();
          checkAchievements();
          return;
        }

        items.splice(i, 1);
      }
    }

    // Check achievements during play
    stats.maxScore = Math.max(stats.maxScore, score);
    stats.maxCombo = Math.max(stats.maxCombo, combo);
    saveStats();
    checkAchievements();
  }

  // ‚îÄ‚îÄ‚îÄ Draw ‚îÄ‚îÄ‚îÄ
  function draw() {
    ctx.save();
    
    // Screen shake
    if (screenShake > 0) {
      ctx.translate(
        (Math.random() - 0.5) * screenShake,
        (Math.random() - 0.5) * screenShake
      );
    }

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background gradient
    const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
    grad.addColorStop(0, '#1a1a2e');
    grad.addColorStop(1, '#16213e');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Ground line
    ctx.strokeStyle = '#30475e';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, canvas.height - 5);
    ctx.lineTo(canvas.width, canvas.height - 5);
    ctx.stroke();

    // Falling items
    items.forEach(item => {
      if (item.isPowerUp) {
        // Power-up visual
        ctx.save();
        ctx.globalAlpha = 0.8 + Math.sin(Date.now() / 200) * 0.2;
        ctx.fillStyle = item.powerUp.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = item.powerUp.color;
        ctx.beginPath();
        ctx.arc(item.x + item.w / 2, item.y + item.h / 2, item.w / 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(item.powerUp.icon, item.x + item.w / 2, item.y + item.h / 2);
        ctx.restore();
      } else {
        ctx.drawImage(sprites[item.type.name], item.x, item.y, item.w, item.h);
      }
    });

    // Particles
    drawParticles();

    // Player (with shadow)
    ctx.save();
    ctx.globalAlpha = 0.3;
    ctx.fillStyle = '#000';
    ctx.fillRect(player.x + 10, player.y + player.h - 5, player.w - 20, 10);
    ctx.globalAlpha = 1;
    ctx.drawImage(sprites.picasso, player.x, player.y, player.w, player.h);
    ctx.restore();

    // HUD ‚Äî Score (top right)
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 24px Arial, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Score: ' + score, canvas.width - 20, 35);

    // HUD ‚Äî Lives (top right, below score) - or Time Remaining for Time Attack
    if (currentMode.timeLimit) {
      const elapsed = performance.now() - gameStartTime;
      const remaining = Math.max(0, Math.ceil((currentMode.timeLimit - elapsed) / 1000));
      ctx.fillStyle = remaining < 10 ? '#ff6b6b' : '#4ECDC4';
      ctx.font = '22px Arial, sans-serif';
      ctx.fillText('‚è±Ô∏è ' + remaining + 's', canvas.width - 20, 65);
    } else if (lives !== Infinity) {
      ctx.fillStyle = '#ff6b6b';
      ctx.font = '22px Arial, sans-serif';
      const hearts = '\u2764'.repeat(lives) + '\u25CB'.repeat(MAX_LIVES - lives);
      ctx.fillText(hearts, canvas.width - 20, 65);
    }

    // HUD ‚Äî Combo (center top)
    if (combo >= 2) {
      const comboScale = 1 + Math.min(combo / 20, 0.5);
      ctx.save();
      ctx.textAlign = 'center';
      ctx.font = `bold ${24 * comboScale}px Arial, sans-serif`;
      const comboAlpha = Math.min(comboTimer / 2000, 1);
      
      // Outline
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      ctx.strokeText(combo + '√ó COMBO!', canvas.width / 2, 50);
      
      // Fill
      ctx.fillStyle = combo >= 10 ? '#FFD700' : combo >= 5 ? '#FFA500' : '#4ECDC4';
      ctx.globalAlpha = comboAlpha;
      ctx.fillText(combo + '√ó COMBO!', canvas.width / 2, 50);
      ctx.restore();
    }

    // HUD ‚Äî Active Power-ups (left side)
    ctx.textAlign = 'left';
    ctx.font = '18px Arial, sans-serif';
    activePowerUps.forEach((powerUp, idx) => {
      const y = 35 + idx * 30;
      const timeLeft = Math.ceil((powerUp.endTime - performance.now()) / 1000);
      ctx.fillStyle = powerUp.color;
      ctx.fillText(`${powerUp.icon} ${powerUp.type.toUpperCase()} (${timeLeft}s)`, 20, y);
    });

    // HUD ‚Äî Sound indicator (top left corner)
    ctx.fillStyle = soundEnabled ? '#4ECDC4' : '#666';
    ctx.font = '20px Arial';
    ctx.fillText(soundEnabled ? 'üîä' : 'üîá', 20, canvas.height - 20);
    ctx.font = '12px Arial';
    ctx.fillText('M', 45, canvas.height - 20);

    // HUD ‚Äî Version number (bottom left)
    ctx.fillStyle = '#666';
    ctx.font = '11px Arial';
    ctx.textAlign = 'left';
    ctx.fillText(GAME_VERSION, 70, canvas.height - 18);

    // Pause button (mobile, top-left)
    if (isMobile && !gameOver && !paused) {
      ctx.save();
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.fillRect(5, 5, 50, 50);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(5, 5, 50, 50);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 30px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText('‚è∏', 30, 30);
      ctx.restore();
    }

    // Achievement notifications (bottom center)
    newAchievements.forEach((ach, idx) => {
      const elapsed = performance.now() - gameStartTime;
      const age = elapsed % 5000; // Show for 5 seconds, cycling
      if (age < 3000 && idx === newAchievements.length - 1) { // Show latest
        const alpha = age < 500 ? age / 500 : age > 2500 ? (3000 - age) / 500 : 1;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.textAlign = 'center';
        
        // Background
        ctx.fillStyle = 'rgba(255, 215, 0, 0.2)';
        ctx.fillRect(canvas.width / 2 - 150, canvas.height - 120, 300, 60);
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 2;
        ctx.strokeRect(canvas.width / 2 - 150, canvas.height - 120, 300, 60);
        
        // Text
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 20px Arial';
        ctx.fillText('üèÜ Achievement Unlocked!', canvas.width / 2, canvas.height - 100);
        ctx.font = '16px Arial';
        ctx.fillStyle = '#fff';
        ctx.fillText(ach.name, canvas.width / 2, canvas.height - 75);
        ctx.restore();
      }
    });

    ctx.restore();

    // Pause Menu
    if (paused && showPauseMenu) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = 'center';
      ctx.fillStyle = '#4ECDC4';
      ctx.font = 'bold 48px Arial, sans-serif';
      ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2 - 120);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const buttonWidth = 200;
      const buttonHeight = 50;

      // Helper function to draw a button
      function drawButton(y, text, enabled = true) {
        ctx.fillStyle = enabled ? 'rgba(78, 205, 196, 0.3)' : 'rgba(100, 100, 100, 0.3)';
        ctx.fillRect(centerX - buttonWidth / 2, y, buttonWidth, buttonHeight);
        ctx.strokeStyle = enabled ? '#4ECDC4' : '#666';
        ctx.lineWidth = 2;
        ctx.strokeRect(centerX - buttonWidth / 2, y, buttonWidth, buttonHeight);
        ctx.fillStyle = enabled ? '#fff' : '#aaa';
        ctx.font = '20px Arial, sans-serif';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, centerX, y + buttonHeight / 2);
      }

      // Resume button
      drawButton(centerY - 60, '‚ñ∂ Resume');

      // Sound toggle
      drawButton(centerY + 10, soundEnabled ? 'üîä Sound: ON' : 'üîá Sound: OFF');

      // Tilt controls (mobile only)
      if (isMobile) {
        drawButton(centerY + 75, tiltEnabled ? 'üì± Tilt: ON' : 'üì± Tilt: OFF');
      }

      // Reset stats
      const resetY = isMobile ? centerY + 140 : centerY + 75;
      drawButton(resetY, 'üóëÔ∏è Reset Stats');

      // Instructions
      ctx.fillStyle = '#aaa';
      ctx.font = '16px Arial, sans-serif';
      const instructY = isMobile ? resetY + 80 : centerY + 150;
      if (isMobile) {
        ctx.fillText('Tap buttons to adjust settings', centerX, instructY);
      } else {
        ctx.fillText('Press ESC or P to resume', centerX, instructY);
        ctx.fillText('Use arrow keys or mouse to move', centerX, instructY + 25);
      }
    }

    // Simple pause indicator (when paused without menu)
    if (paused && !showPauseMenu) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.textAlign = 'center';
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 48px Arial';
      ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
      ctx.font = '20px Arial';
      ctx.fillText('Press ESC or P to resume', canvas.width / 2, canvas.height / 2 + 50);
    }

    // Mode Selection Screen
    if (showModeSelect) {
      ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.textAlign = 'center';
      ctx.fillStyle = '#f8d56b';
      ctx.font = 'bold 48px Arial, sans-serif';
      ctx.fillText('üçî PICASSO CATCH', canvas.width / 2, 100);
      
      ctx.fillStyle = '#aaa';
      ctx.font = '20px Arial, sans-serif';
      ctx.fillText('Select Game Mode', canvas.width / 2, 160);
      
      const centerX = canvas.width / 2;
      const buttonWidth = 300;
      const buttonHeight = 80;
      const startY = 220;
      const spacing = 100;
      
      const modes = [
        { id: 'NORMAL', emoji: 'üéÆ', title: 'NORMAL', desc: '3 lives ‚Ä¢ Power-ups enabled', color: '#4ECDC4' },
        { id: 'ZEN', emoji: 'üßò', title: 'ZEN MODE', desc: 'Infinite lives ‚Ä¢ Slower pace', color: '#95E1D3' },
        { id: 'TIME_ATTACK', emoji: '‚è±Ô∏è', title: 'TIME ATTACK', desc: '60 seconds ‚Ä¢ Fast pace', color: '#F38181' },
        { id: 'HARDCORE', emoji: 'üíÄ', title: 'HARDCORE', desc: '2 lives ‚Ä¢ No power-ups ‚Ä¢ Fast', color: '#AA4465' }
      ];
      
      modes.forEach((mode, idx) => {
        const y = startY + idx * spacing;
        
        // Button background
        ctx.fillStyle = mode.color;
        ctx.fillRect(centerX - buttonWidth / 2, y, buttonWidth, buttonHeight);
        
        // Button border
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.strokeRect(centerX - buttonWidth / 2, y, buttonWidth, buttonHeight);
        
        // Mode title
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 24px Arial, sans-serif';
        ctx.fillText(mode.emoji + ' ' + mode.title, centerX, y + 30);
        
        // Mode description
        ctx.font = '16px Arial, sans-serif';
        ctx.fillText(mode.desc, centerX, y + 55);
      });
      
      return; // Don't draw game elements when in mode select
    }

    // Tutorial Overlay
    if (showTutorial) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      const tutorialSteps = [
        {
          title: 'üëã Welcome to Picasso Catch!',
          text: isMobile ? 'Tilt your device or drag to move Picasso' : 'Use arrow keys or mouse to move Picasso',
          demo: '‚¨ÖÔ∏è üßë‚Äçüç≥ ‚û°Ô∏è'
        },
        {
          title: 'üçñ Catch the Good Food',
          text: 'Catch HRS and ≈†US (+2 points) or Muckalica (+1 point)\nBuild combos by catching multiple items quickly!',
          demo: 'üçñ +2 | ü•ò +1'
        },
        {
          title: 'üéÅ Power-ups',
          text: 'Collect power-ups for special abilities:\nüõ°Ô∏è Shield ‚Ä¢ üïê Slow Mo ‚Ä¢ üß≤ Magnet ‚Ä¢ ‚ú® Double Points',
          demo: 'üéÅ'
        },
        {
          title: 'üçï Avoid Pizza!',
          text: 'Pizza is instant game over!\nDodge it at all costs.',
          demo: 'üçï ‚ò†Ô∏è'
        }
      ];
      
      const step = tutorialSteps[tutorialStep];
      if (!step) {
        showTutorial = false;
        markTutorialSeen();
        showModeSelect = true;
        return;
      }
      
      ctx.textAlign = 'center';
      
      // Title
      ctx.fillStyle = '#f8d56b';
      ctx.font = 'bold 36px Arial, sans-serif';
      ctx.fillText(step.title, canvas.width / 2, 150);
      
      // Demo emoji/visual
      ctx.font = 'bold 48px Arial, sans-serif';
      ctx.fillText(step.demo, canvas.width / 2, 250);
      
      // Text
      ctx.fillStyle = '#fff';
      ctx.font = '20px Arial, sans-serif';
      const lines = step.text.split('\n');
      lines.forEach((line, idx) => {
        ctx.fillText(line, canvas.width / 2, 320 + idx * 30);
      });
      
      // Progress dots
      ctx.font = '24px Arial, sans-serif';
      const dots = tutorialSteps.map((_, idx) => idx === tutorialStep ? '‚ö´' : '‚ö™').join(' ');
      ctx.fillStyle = '#aaa';
      ctx.fillText(dots, canvas.width / 2, canvas.height - 120);
      
      // Next button
      const btnY = canvas.height - 80;
      const btnText = tutorialStep < tutorialSteps.length - 1 ? 'NEXT' : 'START GAME';
      ctx.fillStyle = '#4ECDC4';
      ctx.fillRect(canvas.width / 2 - 100, btnY, 200, 50);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 20px Arial, sans-serif';
      ctx.fillText(btnText, canvas.width / 2, btnY + 33);
      
      // Skip button
      if (tutorialStep < tutorialSteps.length - 1) {
        ctx.fillStyle = '#666';
        ctx.font = '16px Arial, sans-serif';
        ctx.fillText('Skip Tutorial', canvas.width / 2, canvas.height - 20);
      }
      
      return; // Don't draw game elements during tutorial
    }

    // Game Over overlay
    if (gameOver) {
      // Dim overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = 'center';

      // Check if this is a high score that needs name entry
      const isNewHighScore = isHighScore(currentMode.id, score);
      const needsNameEntry = isNewHighScore && !playerName;

      if (needsNameEntry) {
        // Name Entry Screen
        ctx.fillStyle = '#f8d56b';
        ctx.font = 'bold 48px Arial, sans-serif';
        ctx.fillText('üèÜ NEW HIGH SCORE!', canvas.width / 2, 150);

        ctx.fillStyle = '#fff';
        ctx.font = 'bold 36px Arial, sans-serif';
        ctx.fillText('Score: ' + score, canvas.width / 2, 220);

        ctx.font = '24px Arial, sans-serif';
        ctx.fillText('Enter your name:', canvas.width / 2, 280);

        // Name input box
        const inputWidth = 300;
        const inputHeight = 50;
        const inputY = 310;
        ctx.fillStyle = '#fff';
        ctx.fillRect(canvas.width / 2 - inputWidth / 2, inputY, inputWidth, inputHeight);
        ctx.strokeStyle = '#4ECDC4';
        ctx.lineWidth = 3;
        ctx.strokeRect(canvas.width / 2 - inputWidth / 2, inputY, inputWidth, inputHeight);

        // Display entered name
        ctx.fillStyle = '#000';
        ctx.font = '28px Arial, sans-serif';
        ctx.fillText(playerName || '_', canvas.width / 2, inputY + 35);

        // Instructions
        ctx.fillStyle = '#aaa';
        ctx.font = '18px Arial, sans-serif';
        ctx.fillText(isMobile ? 'Tap to enter name' : 'Type your name and press ENTER', canvas.width / 2, inputY + 80);

        return; // Don't show rest of game over screen yet
      }

      // GAME OVER text
      ctx.fillStyle = '#ff6b6b';
      ctx.font = 'bold 48px Arial, sans-serif';
      ctx.fillText('GAME OVER', canvas.width / 2, 80);

      // Reason
      ctx.fillStyle = '#ffffff';
      ctx.font = '20px Arial, sans-serif';
      const reason = lives <= 0 ? (currentMode.timeLimit ? 'Time\'s up!' : 'Out of lives!') : 'You caught a pizza!';
      ctx.fillText(reason, canvas.width / 2, 120);

      // Final score
      ctx.fillStyle = '#f8d56b';
      ctx.font = 'bold 32px Arial, sans-serif';
      ctx.fillText('Score: ' + score, canvas.width / 2, 160);

      // Max combo
      if (maxCombo >= 2) {
        ctx.fillStyle = '#4ECDC4';
        ctx.font = '20px Arial, sans-serif';
        ctx.fillText('Max Combo: ' + maxCombo + '√ó', canvas.width / 2, 190);
      }

      // Leaderboard
      const leaderboard = loadLeaderboard(currentMode.id);
      if (leaderboard.length > 0) {
        ctx.fillStyle = '#f8d56b';
        ctx.font = 'bold 24px Arial, sans-serif';
        ctx.fillText('üèÜ ' + currentMode.name + ' Leaderboard', canvas.width / 2, 230);

        ctx.font = '18px Arial, sans-serif';
        const startY = 260;
        const maxShow = Math.min(5, leaderboard.length);

        for (let i = 0; i < maxShow; i++) {
          const entry = leaderboard[i];
          const y = startY + i * 30;
          
          // Highlight current player's score
          const isPlayerScore = isNewHighScore && entry.score === score && entry.name === playerName;
          if (isPlayerScore) {
            ctx.fillStyle = '#4ECDC4';
            ctx.fillRect(canvas.width / 2 - 180, y - 20, 360, 28);
          }

          ctx.fillStyle = isPlayerScore ? '#000' : '#fff';
          ctx.textAlign = 'left';
          ctx.fillText(`${i + 1}. ${entry.name}`, canvas.width / 2 - 170, y);
          ctx.textAlign = 'right';
          ctx.fillText(`${entry.score}`, canvas.width / 2 + 170, y);
        }

        ctx.textAlign = 'center';
      }

      // Stats
      ctx.fillStyle = '#aaa';
      ctx.font = '16px Arial, sans-serif';
      const statsY = leaderboard.length > 0 ? 420 : 220;
      ctx.fillText(`Best: ${stats.maxScore} | Achievements: ${unlockedAchievements.length}/${ACHIEVEMENTS.length}`, canvas.width / 2, statsY);

      // Restart prompt
      ctx.fillStyle = '#aaa';
      ctx.font = '18px Arial, sans-serif';
      const promptY = leaderboard.length > 0 ? 460 : 260;
      ctx.fillText(isMobile ? 'Tap to Play Again' : 'Press ENTER or Click to Play Again', canvas.width / 2, promptY);

      // Mode selection hint
      ctx.font = '14px Arial, sans-serif';
      ctx.fillText('Press M to change mode', canvas.width / 2, promptY + 25);
    }
  }

  // ‚îÄ‚îÄ‚îÄ Game Loop ‚îÄ‚îÄ‚îÄ
  function loop(now) {
    update(now);
    draw();
    animFrameId = requestAnimationFrame(loop);
  }

  // ‚îÄ‚îÄ‚îÄ Start / Restart ‚îÄ‚îÄ‚îÄ
  function startGame() {
    if (animFrameId) cancelAnimationFrame(animFrameId);

    // Save high score from previous game if applicable
    if (gameOver && score > 0 && playerName) {
      // Already saved during name entry, just reset
      playerName = '';
    }

    resetState();
    lastSpawn = performance.now();
    pointerX = null;
    animFrameId = requestAnimationFrame(loop);
  }

  // ‚îÄ‚îÄ‚îÄ Initial Setup ‚îÄ‚îÄ‚îÄ
  function init() {
    // Check if first time user
    if (!hasSeenTutorial()) {
      showTutorial = true;
      tutorialStep = 0;
    } else {
      showModeSelect = true;
    }
    
    // Start the render loop (will show tutorial or mode select)
    animFrameId = requestAnimationFrame(loop);
  }

  // ‚îÄ‚îÄ‚îÄ Loading Screen then Start ‚îÄ‚îÄ‚îÄ
  function drawLoadingScreen() {
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ffffff';
    ctx.font = '28px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Loading...', canvas.width / 2, canvas.height / 2);
  }

  drawLoadingScreen();
  loadAssets(() => init());
})();

// Register Service Worker with update checking
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').then(reg => {
    // Check for updates every 60 seconds
    setInterval(() => {
      reg.update();
    }, 60000);

    // Listen for updates
    reg.addEventListener('updatefound', () => {
      const newWorker = reg.installing;
      newWorker.addEventListener('statechange', () => {
        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
          // New version available - show notification
          if (confirm('üéÆ New version of Picasso Catch available! Reload to update?')) {
            newWorker.postMessage({ action: 'skipWaiting' });
            window.location.reload();
          }
        }
      });
    });

    // Handle controller change (new service worker activated)
    navigator.serviceWorker.addEventListener('controllerchange', () => {
      window.location.reload();
    });
  }).catch(err => console.warn('SW registration failed:', err));
}
</script>
</body>
</html>
